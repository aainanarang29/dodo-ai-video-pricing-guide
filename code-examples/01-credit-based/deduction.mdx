---
title: 'Credit Deduction & Tracking'
description: 'Deduct credits during video generation and track consumption'
---

## Credit Deduction Flow

When a user generates a video, calculate and deduct the appropriate credits based on video length and settings.

## Video Generation with Credit Check

```typescript
import { db } from '@/lib/database';

interface VideoGenerationRequest {
  userId: string;
  duration: number; // in seconds
  resolution: '720p' | '1080p' | '4K';
  modelType: 'standard' | 'pro';
}

interface CreditCost {
  baseCredits: number;
  resolutionMultiplier: number;
  modelMultiplier: number;
  totalCredits: number;
}

export async function generateVideo(request: VideoGenerationRequest) {
  const { userId, duration, resolution, modelType } = request;

  // 1. Calculate credit cost
  const cost = calculateCreditCost(duration, resolution, modelType);

  // 2. Check if user has sufficient credits
  const userCredits = await getUserCredits(userId);
  
  if (userCredits.balance < cost.totalCredits) {
    throw new Error(
      `Insufficient credits. Required: ${cost.totalCredits}, Available: ${userCredits.balance}`
    );
  }

  // 3. Deduct credits BEFORE generation (optimistic deduction)
  const deduction = await deductCredits({
    userId,
    amount: cost.totalCredits,
    videoMetadata: {
      duration,
      resolution,
      modelType,
      estimatedCost: cost
    }
  });

  try {
    // 4. Generate video
    const video = await runwayAPI.generateVideo({
      duration,
      resolution,
      model: modelType === 'pro' ? 'gen3_turbo' : 'gen2'
    });

    // 5. Update transaction with video ID
    await db.query(`
      UPDATE credit_transactions 
      SET video_id = $1, metadata = metadata || $2
      WHERE id = $3
    `, [
      video.id,
      JSON.stringify({ status: 'completed', actual_duration: video.duration }),
      deduction.transactionId
    ]);

    return {
      video,
      creditsDeducted: cost.totalCredits,
      remainingCredits: deduction.balanceAfter
    };

  } catch (error) {
    // Refund credits on failure
    await refundCredits({
      userId,
      amount: cost.totalCredits,
      reason: 'Video generation failed',
      originalTransactionId: deduction.transactionId
    });

    throw error;
  }
}

function calculateCreditCost(
  duration: number,
  resolution: string,
  modelType: string
): CreditCost {
  // Base: 1 credit per 4 seconds of video
  const baseCredits = Math.ceil(duration / 4);

  // Resolution multiplier
  const resolutionMultipliers = {
    '720p': 1.0,
    '1080p': 1.5,
    '4K': 2.5
  };
  const resolutionMultiplier = resolutionMultipliers[resolution] || 1.0;

  // Model multiplier
  const modelMultiplier = modelType === 'pro' ? 1.3 : 1.0;

  // Total cost
  const totalCredits = Math.ceil(
    baseCredits * resolutionMultiplier * modelMultiplier
  );

  return {
    baseCredits,
    resolutionMultiplier,
    modelMultiplier,
    totalCredits
  };
}
```

## Credit Deduction Function

```typescript
interface DeductCreditsParams {
  userId: string;
  amount: number;
  videoMetadata: Record<string, any>;
}

interface DeductionResult {
  transactionId: string;
  balanceAfter: number;
  deductedAt: Date;
}

async function deductCredits({
  userId,
  amount,
  videoMetadata
}: DeductCreditsParams): Promise<DeductionResult> {
  // Begin transaction
  const client = await db.getClient();
  
  try {
    await client.query('BEGIN');

    // Lock user's credit row
    const userCredits = await client.query(`
      SELECT * FROM user_credits 
      WHERE user_id = $1 
      FOR UPDATE
    `, [userId]);

    if (userCredits.rows.length === 0) {
      throw new Error('User credit account not found');
    }

    const currentBalance = userCredits.rows[0].balance;

    if (currentBalance < amount) {
      throw new Error(
        `Insufficient credits: have ${currentBalance}, need ${amount}`
      );
    }

    // Update balance
    const newBalance = currentBalance - amount;
    await client.query(`
      UPDATE user_credits 
      SET 
        balance = $1,
        total_consumed = total_consumed + $2,
        updated_at = NOW()
      WHERE user_id = $3
    `, [newBalance, amount, userId]);

    // Log transaction
    const transaction = await client.query(`
      INSERT INTO credit_transactions 
        (user_id, type, amount, balance_after, metadata)
      VALUES ($1, 'consumption', $2, $3, $4)
      RETURNING id, created_at
    `, [
      userId,
      -amount, // Negative for deduction
      newBalance,
      JSON.stringify(videoMetadata)
    ]);

    await client.query('COMMIT');

    return {
      transactionId: transaction.rows[0].id,
      balanceAfter: newBalance,
      deductedAt: transaction.rows[0].created_at
    };

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

## Credit Refund Function

```typescript
async function refundCredits({
  userId,
  amount,
  reason,
  originalTransactionId
}: {
  userId: string;
  amount: number;
  reason: string;
  originalTransactionId: string;
}) {
  const client = await db.getClient();
  
  try {
    await client.query('BEGIN');

    // Add credits back
    const result = await client.query(`
      UPDATE user_credits 
      SET 
        balance = balance + $1,
        total_consumed = total_consumed - $1,
        updated_at = NOW()
      WHERE user_id = $2
      RETURNING balance
    `, [amount, userId]);

    // Log refund transaction
    await client.query(`
      INSERT INTO credit_transactions 
        (user_id, type, amount, balance_after, metadata)
      VALUES ($1, 'refund', $2, $3, $4)
    `, [
      userId,
      amount,
      result.rows[0].balance,
      JSON.stringify({
        reason,
        original_transaction_id: originalTransactionId
      })
    ]);

    await client.query('COMMIT');

    console.log(`Refunded ${amount} credits to user ${userId}: ${reason}`);
    return result.rows[0].balance;

  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

## Frontend Credit Display

```typescript
'use client';

import { useEffect, useState } from 'react';

export function CreditBalance() {
  const [credits, setCredits] = useState<number>(0);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchCredits();
  }, []);

  const fetchCredits = async () => {
    try {
      const res = await fetch('/api/user/credits');
      const data = await res.json();
      setCredits(data.balance);
    } catch (error) {
      console.error('Failed to fetch credits:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) return <div>Loading...</div>;

  return (
    <div className="bg-gradient-to-r from-blue-500 to-purple-600 p-6 rounded-lg text-white">
      <div className="text-sm opacity-90">Available Credits</div>
      <div className="text-4xl font-bold mt-2">{credits.toLocaleString()}</div>
      <div className="text-sm mt-2 opacity-75">
        â‰ˆ {Math.floor(credits * 4)} seconds of video
      </div>
      {credits < 10 && (
        <button className="mt-4 bg-white text-purple-600 px-4 py-2 rounded-lg font-semibold">
          Buy More Credits
        </button>
      )}
    </div>
  );
}
```

## Pre-Generation Credit Check

```typescript
export function VideoGenerationForm() {
  const [duration, setDuration] = useState(10);
  const [resolution, setResolution] = useState('1080p');
  const [estimatedCost, setEstimatedCost] = useState(0);
  const [userCredits, setUserCredits] = useState(0);

  useEffect(() => {
    // Calculate estimated cost
    const cost = calculateCreditCost(duration, resolution, 'standard');
    setEstimatedCost(cost.totalCredits);
  }, [duration, resolution]);

  const canGenerate = userCredits >= estimatedCost;

  return (
    <div>
      <input 
        type="range" 
        min="5" 
        max="30" 
        value={duration}
        onChange={(e) => setDuration(Number(e.target.value))}
      />
      <div className="text-sm">Duration: {duration}s</div>

      <select 
        value={resolution} 
        onChange={(e) => setResolution(e.target.value)}
      >
        <option value="720p">720p (1x credits)</option>
        <option value="1080p">1080p (1.5x credits)</option>
        <option value="4K">4K (2.5x credits)</option>
      </select>

      <div className="mt-4 p-4 bg-gray-100 rounded">
        <div>Estimated Cost: <strong>{estimatedCost} credits</strong></div>
        <div className="text-sm text-gray-600">
          Your Balance: {userCredits} credits
        </div>
      </div>

      <button 
        disabled={!canGenerate}
        className={canGenerate ? 'bg-blue-600' : 'bg-gray-300'}
      >
        {canGenerate ? 'Generate Video' : 'Insufficient Credits'}
      </button>
    </div>
  );
}
```

## Usage Analytics

Track credit consumption patterns:

```sql
-- Daily credit consumption
SELECT 
  DATE(created_at) as date,
  COUNT(*) as generations,
  SUM(ABS(amount)) as credits_used,
  AVG(ABS(amount)) as avg_credits_per_video
FROM credit_transactions
WHERE type = 'consumption'
  AND created_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(created_at)
ORDER BY date DESC;

-- Top spenders
SELECT 
  user_id,
  SUM(ABS(amount)) as total_consumed,
  COUNT(*) as total_generations,
  AVG(ABS(amount)) as avg_per_generation
FROM credit_transactions
WHERE type = 'consumption'
GROUP BY user_id
ORDER BY total_consumed DESC
LIMIT 10;
```

## Best Practices

1. **Deduct Before Generation**: Prevents abuse and ensures fair usage
2. **Refund on Failure**: Maintain user trust by refunding failed generations
3. **Transaction Locks**: Use database locks to prevent race conditions
4. **Show Estimates**: Display cost before generation starts
5. **Low Balance Alerts**: Notify users when credits are running low
6. **Batch Operations**: For bulk generations, calculate total cost upfront

<Card title="View Complete Guide" icon="book" href="/blog/complete-pricing-guide">
  See all 7 pricing models in the complete guide
</Card>
